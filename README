POJ的代码风格很竞赛。主要体现在牺牲了可读性和容错性，换取极致效率。比如为了节省编码时间，把变量名都写得非常短，可读性很差。这点非常不值得学习。

注意事项：
1. max函数要自己写，否则会Compile Error。
2. RE的结果，也有可能是栈溢出导致。
3. 大块内存，尽量动态分配。否则可能导致RE。
4. 不支持unordered_map。可以自己实现hash table或者用map代替。
5. struct的constructor需要对每一个argument有默认输入值。
6. 解图论问题时，经常可以构造一个包含题目所给graph的supergraph，再解决。比如1237，不妨假设图中有26个vertices，但有些字母没有edge。问题就得到简化了。
7. vector的resize和reserve，并不是reset。如果想做的是reset，最好先clear，再resize。
8. ACM竞赛中使用大量的模板，相当关于围棋的定式，桥牌中的单套结构。都是反复出现，已经总结成固定套路的东西。我数学竞赛一等奖，相当于业五。围棋、桥牌，了解很多定式，并且已经开始思考定式的场合变化，说明有了业二业三的水平。ACM刚开始了解定式，也就是刚刚业余初段的样子，这实在是拿不出手。这是一个程序员的内力，必须提高。提高并非一日之功，必须平日里下功夫，不要等到面试时候再临时抱佛脚。

ACM业余初段：
LeetCode刷遍
LintCode刷遍
PE 50题。
POJ 50题。
对个别常用的模板有基本了解。

ACM业余二段：
PE 100题。
POJ 100题。
对所有常用的模板有基本了解。
偶尔参加OJ比赛。

ACM业余三段：
PE 200题。
POJ 300题。
对其他高手的模板，解题代码有相当阅读量。
了解不同模板版本的优劣。

ACM业余四段：
PE 300题。
POJ 500题。
能实现部分简单模板。

ACM业余五段：
PE 400题。
POJ 800题。
能实现大部分常用模板。
对于不同数据结构下的常用算法实现复杂度有相当了解。

ACM业余六段，接近职业水平：
PE 500题。
POJ 1000题。
对于代码中最可能出现问题的地方有相当的直觉。能快递理解题意，快速分析算法，快速编码，快速debug。
经常参加OJ比赛，名列前茅。

9. 碰到死也看不出来的bug时（多半是0这种corner case），就找题目出处。一般比赛过后，测试数据会公布，可以有针对性地debug。
10. 不要重新造轮子！不要重新造轮子！不要重新造轮子！人家有的东西，直接用就好了嘛！

bipartite graph
http://www.cnblogs.com/pony1993/archive/2012/07/25/2607738.html

ACRush模板
1003

bignum模板最新版
release 1220
